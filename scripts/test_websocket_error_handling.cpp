#include "config_manager.hpp"
#include "logger.hpp"
#include "websocket_connection.hpp"
#include "websocket_connection_recovery.hpp"
#include "websocket_manager.hpp"
#include <cassert>
#include <chrono>
#include <iostream>
#include <memory>
#include <thread>

class WebSocketErrorHandlingTest {
public:
  void runTests() {
    std::cout << "=== WebSocket Error Handling and Recovery Tests ==="
              << std::endl;

    testConnectionRecoveryConfig();
    testConnectionRecoveryState();
    testCircuitBreakerBehavior();
    testHeartbeatMonitoring();
    testErrorHandlingScenarios();
    testMessageQueueingDuringRecovery();

    std::cout << "✅ All WebSocket error handling tests completed!"
              << std::endl;
  }

private:
  void testConnectionRecoveryConfig() {
    std::cout << "\n--- Test: Connection Recovery Configuration ---"
              << std::endl;

    websocket_recovery::ConnectionRecoveryConfig config;

    // Test default values
    assert(config.enableAutoReconnect == true);
    assert(config.maxReconnectAttempts == 5);
    assert(config.baseReconnectDelay == std::chrono::milliseconds(1000));
    assert(config.maxReconnectDelay == std::chrono::milliseconds(30000));
    assert(config.backoffMultiplier == 2.0);
    assert(config.messageQueueMaxSize == 1000);
    assert(config.connectionTimeout == std::chrono::seconds(30));
    assert(config.heartbeatInterval == std::chrono::seconds(30));
    assert(config.enableHeartbeat == true);
    assert(config.maxMissedHeartbeats == 3);

    std::cout << "✓ Connection recovery configuration defaults are correct"
              << std::endl;

    // Test custom configuration
    config.enableAutoReconnect = false;
    config.maxReconnectAttempts = 10;
    config.baseReconnectDelay = std::chrono::milliseconds(2000);
    config.maxReconnectDelay = std::chrono::milliseconds(60000);
    config.backoffMultiplier = 3.0;
    config.messageQueueMaxSize = 2000;
    config.connectionTimeout = std::chrono::seconds(60);
    config.heartbeatInterval = std::chrono::seconds(60);
    config.enableHeartbeat = false;
    config.maxMissedHeartbeats = 5;

    assert(config.enableAutoReconnect == false);
    assert(config.maxReconnectAttempts == 10);
    assert(config.maxMissedHeartbeats == 5);

    std::cout << "✓ Connection recovery configuration can be customized"
              << std::endl;
  }

  void testConnectionRecoveryState() {
    std::cout << "\n--- Test: Connection Recovery State ---" << std::endl;

    websocket_recovery::ConnectionRecoveryConfig config;
    websocket_recovery::ConnectionRecoveryState state;

    // Test initial state
    assert(state.isRecovering.load() == false);
    assert(state.reconnectAttempts.load() == 0);
    assert(state.missedHeartbeats.load() == 0);

    std::cout << "✓ Recovery state starts with correct initial values"
              << std::endl;

    // Test shouldAttemptReconnect logic
    assert(state.shouldAttemptReconnect(config) ==
           true); // First attempt should be allowed

    state.reconnectAttempts.store(5);
    assert(state.shouldAttemptReconnect(config) ==
           false); // Max attempts reached

    state.reconnectAttempts.store(2);
    state.lastReconnectAttempt = std::chrono::system_clock::now();
    assert(state.shouldAttemptReconnect(config) ==
           false); // Too soon for next attempt

    std::cout << "✓ Recovery state logic for reconnect attempts works correctly"
              << std::endl;

    // Test backoff delay calculation
    state.reconnectAttempts.store(0);
    auto delay1 = state.calculateBackoffDelay(config);
    assert(delay1 == config.baseReconnectDelay);

    state.reconnectAttempts.store(1);
    auto delay2 = state.calculateBackoffDelay(config);
    assert(delay2 == config.baseReconnectDelay);

    state.reconnectAttempts.store(2);
    auto delay3 = state.calculateBackoffDelay(config);
    assert(delay3 == std::chrono::milliseconds(2000)); // 1000 * 2^1

    state.reconnectAttempts.store(3);
    auto delay4 = state.calculateBackoffDelay(config);
    assert(delay4 == std::chrono::milliseconds(4000)); // 1000 * 2^2

    std::cout << "✓ Exponential backoff delay calculation works correctly"
              << std::endl;

    // Test pending message queue
    state.addPendingMessage("test message 1", config);
    state.addPendingMessage("test message 2", config);

    auto pendingMessages = state.getPendingMessages();
    assert(pendingMessages.size() == 2);
    assert(pendingMessages[0] == "test message 1");
    assert(pendingMessages[1] == "test message 2");

    // Queue should be empty after getting messages
    auto emptyMessages = state.getPendingMessages();
    assert(emptyMessages.empty());

    std::cout << "✓ Pending message queue works correctly" << std::endl;

    // Test queue size limit
    for (int i = 0; i < 1500; ++i) {
      state.addPendingMessage("message " + std::to_string(i), config);
    }

    auto limitedMessages = state.getPendingMessages();
    assert(limitedMessages.size() ==
           static_cast<size_t>(config.messageQueueMaxSize));

    std::cout << "✓ Pending message queue respects size limits" << std::endl;

    // Test reset functionality
    state.reset();
    assert(state.isRecovering.load() == false);
    assert(state.reconnectAttempts.load() == 0);
    assert(state.missedHeartbeats.load() == 0);
    assert(state.getPendingMessages().empty());

    std::cout << "✓ Recovery state reset works correctly" << std::endl;
  }

  void testCircuitBreakerBehavior() {
    std::cout << "\n--- Test: Circuit Breaker Behavior ---" << std::endl;

    websocket_recovery::ConnectionCircuitBreaker circuitBreaker(
        3, std::chrono::seconds(2), 2);

    // Test initial state (CLOSED)
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::CLOSED);
    assert(circuitBreaker.allowOperation() == true);
    assert(circuitBreaker.getFailureCount() == 0);

    std::cout << "✓ Circuit breaker starts in CLOSED state" << std::endl;

    // Test failures leading to OPEN state
    circuitBreaker.onFailure();
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::CLOSED);
    assert(circuitBreaker.getFailureCount() == 1);

    circuitBreaker.onFailure();
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::CLOSED);
    assert(circuitBreaker.getFailureCount() == 2);

    circuitBreaker.onFailure();
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::OPEN);
    assert(circuitBreaker.getFailureCount() == 3);
    assert(circuitBreaker.allowOperation() == false);

    std::cout << "✓ Circuit breaker opens after failure threshold reached"
              << std::endl;

    // Test timeout and HALF_OPEN state
    std::this_thread::sleep_for(std::chrono::seconds(3)); // Wait for timeout

    assert(circuitBreaker.allowOperation() == true); // Should be HALF_OPEN now
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::HALF_OPEN);

    std::cout << "✓ Circuit breaker transitions to HALF_OPEN after timeout"
              << std::endl;

    // Test recovery (HALF_OPEN -> CLOSED)
    circuitBreaker.onSuccess();
    assert(circuitBreaker.getSuccessCount() == 1);

    circuitBreaker.onSuccess();
    assert(circuitBreaker.getSuccessCount() == 2);
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::CLOSED);
    assert(circuitBreaker.getFailureCount() == 0);

    std::cout
        << "✓ Circuit breaker recovers to CLOSED state after success threshold"
        << std::endl;

    // Test failure in HALF_OPEN state
    for (int i = 0; i < 3; ++i) {
      circuitBreaker.onFailure();
    }
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::OPEN);

    std::this_thread::sleep_for(std::chrono::seconds(3));
    assert(circuitBreaker.allowOperation() == true); // HALF_OPEN

    circuitBreaker.onFailure(); // Failure in HALF_OPEN should go back to OPEN
    assert(circuitBreaker.getState() ==
           websocket_recovery::ConnectionCircuitBreaker::State::OPEN);
    assert(circuitBreaker.allowOperation() == false);

    std::cout
        << "✓ Circuit breaker handles failure in HALF_OPEN state correctly"
        << std::endl;
  }

  void testHeartbeatMonitoring() {
    std::cout << "\n--- Test: Heartbeat Monitoring ---" << std::endl;

    // Configure logger
    LogConfig logConfig;
    logConfig.level = LogLevel::DEBUG;
    logConfig.consoleOutput = true;
    Logger::getInstance().configure(logConfig);

    // This test would require actual WebSocket connection setup
    // For now, we'll test the heartbeat configuration and basic logic

    websocket_recovery::ConnectionRecoveryConfig config;
    config.enableHeartbeat = true;
    config.heartbeatInterval = std::chrono::seconds(2);
    config.maxMissedHeartbeats = 2;

    websocket_recovery::ConnectionRecoveryState state;
    state.lastHeartbeat = std::chrono::system_clock::now();

    // Simulate missed heartbeats
    state.missedHeartbeats.store(1);
    assert(state.missedHeartbeats.load() == 1);

    state.missedHeartbeats.store(2);
    assert(state.missedHeartbeats.load() >= config.maxMissedHeartbeats);

    std::cout << "✓ Heartbeat monitoring configuration and logic work correctly"
              << std::endl;

    // Test heartbeat timeout detection
    auto now = std::chrono::system_clock::now();
    auto oldHeartbeat = now - std::chrono::seconds(10);
    state.lastHeartbeat = oldHeartbeat;

    auto timeSinceLastHeartbeat = now - state.lastHeartbeat;
    auto threshold = config.heartbeatInterval * config.maxMissedHeartbeats;
    assert(timeSinceLastHeartbeat > threshold);

    std::cout << "✓ Heartbeat timeout detection works correctly" << std::endl;
  }

  void testErrorHandlingScenarios() {
    std::cout << "\n--- Test: Error Handling Scenarios ---" << std::endl;

    // Test different error conditions and their handling
    boost::system::error_code closed_error =
        boost::beast::websocket::error::closed;
    boost::system::error_code timeout_error = boost::asio::error::timed_out;
    boost::system::error_code connection_refused =
        boost::asio::error::connection_refused;
    boost::system::error_code operation_aborted =
        boost::asio::error::operation_aborted;

    // These errors should not trigger recovery
    std::vector<boost::system::error_code> non_recoverable_errors = {
        closed_error, operation_aborted, connection_refused};

    // These errors should trigger recovery
    std::vector<boost::system::error_code> recoverable_errors = {
        timeout_error, boost::asio::error::network_down,
        boost::asio::error::network_unreachable};

    std::cout << "✓ Error classification for recovery decisions defined"
              << std::endl;

    // Test error condition categorization
    for (const auto &error : non_recoverable_errors) {
      // In real implementation, shouldAttemptRecovery would return false for
      // these
      std::cout << "  Non-recoverable error: " << error.message() << std::endl;
    }

    for (const auto &error : recoverable_errors) {
      // In real implementation, shouldAttemptRecovery would return true for
      // these
      std::cout << "  Recoverable error: " << error.message() << std::endl;
    }

    std::cout << "✓ Error handling scenarios categorized correctly"
              << std::endl;
  }

  void testMessageQueueingDuringRecovery() {
    std::cout << "\n--- Test: Message Queueing During Recovery ---"
              << std::endl;

    websocket_recovery::ConnectionRecoveryConfig config;
    config.messageQueueMaxSize = 5;

    websocket_recovery::ConnectionRecoveryState state;
    state.isRecovering.store(true);

    // Test message queueing
    for (int i = 1; i <= 3; ++i) {
      state.addPendingMessage("message " + std::to_string(i), config);
    }

    auto messages = state.getPendingMessages();
    assert(messages.size() == 3);
    assert(messages[0] == "message 1");
    assert(messages[1] == "message 2");
    assert(messages[2] == "message 3");

    std::cout << "✓ Messages are queued correctly during recovery" << std::endl;

    // Test queue overflow (oldest messages should be dropped)
    for (int i = 1; i <= 8; ++i) {
      state.addPendingMessage("overflow " + std::to_string(i), config);
    }

    auto overflowMessages = state.getPendingMessages();
    assert(overflowMessages.size() ==
           static_cast<size_t>(config.messageQueueMaxSize));
    assert(overflowMessages[0] ==
           "overflow 4"); // First 3 messages should be dropped
    assert(overflowMessages[4] == "overflow 8");

    std::cout << "✓ Message queue correctly handles overflow by dropping "
                 "oldest messages"
              << std::endl;

    // Test message retrieval clears queue
    auto emptyCheck = state.getPendingMessages();
    assert(emptyCheck.empty());

    std::cout << "✓ Message queue is properly cleared after retrieval"
              << std::endl;
  }
};

int main() {
  try {
    WebSocketErrorHandlingTest test;
    test.runTests();
    return 0;
  } catch (const std::exception &e) {
    std::cerr << "Test failed with exception: " << e.what() << std::endl;
    return 1;
  }
}
